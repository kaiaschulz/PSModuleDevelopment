<#
This script publishes the module to the gallery.
It expects as input an ApiKey authorized to publish the module.

Insert any build steps you may need to take before publishing it here.
#>
param (
	$ApiKey,
	
	$WorkingDirectory,
	
	$Repository = 'PSGallery',
	
	[switch]
	$LocalRepo,
	
	[switch]
	$SkipPublish,

	[switch]
	$StorageAccount,

	[switch]
	$AutomationAccount,
	
	[switch]
	$AutoVersion,

	[string]
	$ModuleSource,

	[string]
	$KeyVaultName,

	[string]
	$KeyVaultSecretNameSasToken,

	[string]
	$SasToken,

	[string]
	$StorageAccountSubscriptionId,

	[string]
	$StorageAccountName,

	[string]
	$StorageAccountContainer,

	[bool]
	$StorageAccountContainerCreate,

	[string]
	$StorageAccountBlobName,

	[bool]
	$StorageAccountBlobOverwrite,

	[string]
	$AutomationAccountSubscriptionId,

	[string]
	$AutomationAccountResourceGroupName,

	[string]
	$AutomationAccountName,

	[string]
	$AutomationAccountModuleName
)

#region Handle Working Directory Defaults
if (-not $WorkingDirectory)
{
	if ($env:RELEASE_PRIMARYARTIFACTSOURCEALIAS)
	{
		$WorkingDirectory = Join-Path -Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY -ChildPath $env:RELEASE_PRIMARYARTIFACTSOURCEALIAS
	}
	else { $WorkingDirectory = $env:SYSTEM_DEFAULTWORKINGDIRECTORY }
}
if (-not $WorkingDirectory) { $WorkingDirectory = Split-Path $PSScriptRoot }
#endregion Handle Working Directory Defaults

# Prepare publish folder
Write-PSFMessage -Level Important -Message "Creating and populating publishing directory"
$publishDir = New-Item -Path $WorkingDirectory -Name publish -ItemType Directory
Copy-Item -Path "$($WorkingDirectory)\PSModuleDevelopment" -Destination $publishDir.FullName -Recurse -Force

#region Gather text data to compile
$text = @()
$processed = @()

# Gather Stuff to run before
foreach ($line in (Get-Content "$($PSScriptRoot)\filesBefore.txt" | Where-Object { $_ -notlike "#*" }))
{
	if ([string]::IsNullOrWhiteSpace($line)) { continue }
	
	$basePath = Join-Path "$($publishDir.FullName)\PSModuleDevelopment" $line
	foreach ($entry in (Resolve-PSFPath -Path $basePath))
	{
		$item = Get-Item $entry
		if ($item.PSIsContainer) { continue }
		if ($item.FullName -in $processed) { continue }
		$text += [System.IO.File]::ReadAllText($item.FullName)
		$processed += $item.FullName
	}
}

# Gather commands
Get-ChildItem -Path "$($publishDir.FullName)\PSModuleDevelopment\internal\functions\" -Recurse -File -Filter "*.ps1" | ForEach-Object {
	$text += [System.IO.File]::ReadAllText($_.FullName)
}
Get-ChildItem -Path "$($publishDir.FullName)\PSModuleDevelopment\functions\" -Recurse -File -Filter "*.ps1" | ForEach-Object {
	$text += [System.IO.File]::ReadAllText($_.FullName)
}

# Gather stuff to run afterwards
foreach ($line in (Get-Content "$($PSScriptRoot)\filesAfter.txt" | Where-Object { $_ -notlike "#*" }))
{
	if ([string]::IsNullOrWhiteSpace($line)) { continue }
	
	$basePath = Join-Path "$($publishDir.FullName)\PSModuleDevelopment" $line
	foreach ($entry in (Resolve-PSFPath -Path $basePath))
	{
		$item = Get-Item $entry
		if ($item.PSIsContainer) { continue }
		if ($item.FullName -in $processed) { continue }
		$text += [System.IO.File]::ReadAllText($item.FullName)
		$processed += $item.FullName
	}
}
#endregion Gather text data to compile

#region Update the psm1 file
$fileData = Get-Content -Path "$($publishDir.FullName)\PSModuleDevelopment\PSModuleDevelopment.psm1" -Raw
$fileData = $fileData.Replace('"<was not compiled>"', '"<was compiled>"')
$fileData = $fileData.Replace('"<compile code into here>"', ($text -join "`n`n"))
[System.IO.File]::WriteAllText("$($publishDir.FullName)\PSModuleDevelopment\PSModuleDevelopment.psm1", $fileData, [System.Text.Encoding]::UTF8)
#endregion Update the psm1 file

#region Build Templates
Import-Module "$($WorkingDirectory)\PSModuleDevelopment\PSModuleDevelopment.psd1"
Write-PSFMessage -Level Host -Message "Building templates"
Write-PSFMessage -Level Host -Message "  Creating root folder"
$templateBuild = New-Item -Path $WorkingDirectory -Name "Templates_Build" -ItemType Directory -Force
Write-PSFMessage -Level Host -Message "  Executing package compilation"
& "$($WorkingDirectory)\templates\build.ps1" -Path $templateBuild.FullName
Write-PSFMessage -Level Host -Message "  Merging template packages into build"
Copy-Item -Path "$($templateBuild.FullName)\output\*" -Destination "$($publishDir.FullName)\PSModuleDevelopment\internal\templates" -Force
#endregion Build Templates

#region Updating the Module Version
if ($AutoVersion)
{
	Write-PSFMessage -Level Important -Message "Updating module version numbers."
	try { [version]$remoteVersion = (Find-Module 'PSModuleDevelopment' -Repository $Repository -ErrorAction Stop).Version }
	catch
	{
		Stop-PSFFunction -Message "Failed to access $($Repository)" -EnableException $true -ErrorRecord $_
	}
	if (-not $remoteVersion)
	{
		Stop-PSFFunction -Message "Couldn't find PSModuleDevelopment on repository $($Repository)" -EnableException $true
	}
	$newBuildNumber = $remoteVersion.Build + 1
	[version]$localVersion = (Import-PowerShellDataFile -Path "$($publishDir.FullName)\PSModuleDevelopment\PSModuleDevelopment.psd1").ModuleVersion
	Update-ModuleManifest -Path "$($publishDir.FullName)\PSModuleDevelopment\PSModuleDevelopment.psd1" -ModuleVersion "$($localVersion.Major).$($localVersion.Minor).$($newBuildNumber)"
}
#endregion Updating the Module Version

#region Publish
if ($SkipPublish) { return }
if ($LocalRepo)
{
	# Dependencies must go first
	Write-PSFMessage -Level Important -Message "Creating Nuget Package for module: PSFramework"
	New-PSMDModuleNugetPackage -ModulePath (Get-Module -Name PSFramework).ModuleBase -PackagePath .
	Write-PSFMessage -Level Important -Message "Creating Nuget Package for module: PSModuleDevelopment"
	New-PSMDModuleNugetPackage -ModulePath "$($publishDir.FullName)\PSModuleDevelopment" -PackagePath .
}
else
{
	# Publish to Gallery
	Write-PSFMessage -Level Important -Message "Publishing the PSModuleDevelopment module to $($Repository)"
	Publish-Module -Path "$($publishDir.FullName)\PSModuleDevelopment" -NuGetApiKey $ApiKey -Force -Repository $Repository
}
if ($StorageAccount -or $AutomationAccount) 
{
	if ($StorageAccount -and $AutomationAccount -and !($(Split-Path -Path $ModuleSource -Extension) -eq ".zip")) 
	{
		Compress-Archive -Path "$($ModuleSource)\*" -DestinationPath "$AutomationAccountModuleName.zip"
	}
	Connect-AzAccount

	Write-PSMDFileToStorageAccount -Source $ModuleSource `
								   -KeyVaultName $KeyVaultName `
								   -KeyVaultSecretNameSasToken $KeyVaultSecretNameSasToken `
								   -SasToken $SasToken `
								   -StorageAccountSubscriptionId $StorageAccountSubscriptionId `
								   -StorageAccountName $StorageAccountName `
								   -StorageAccountContainer $StorageAccountContainer `
								   -StorageAccountContainerCreate $StorageAccountContainerCreate `
								   -StorageAccountBlobName $StorageAccountBlobName `
								   -StorageAccountBlobOverwrite $StorageAccountBlobOverwrite
	if ($AutomationAccount) {
		[uri]$StorageAccountModuleLink = "https://$($StorageAccountName).blob.core.windows.net/$($StorageAccountContainer)/$($ModuleName)?$($SasToken)"
		Publish-PSMDModuleToAutomationAccount -AutomationAccountSubscriptionId $AutomationAccountSubscriptionId `
											  -AutomationAccountResourceGroupName $AutomationAccountResourceGroupName `
											  -AutomationAccountName $AutomationAccountName `
											  -ModuleLink $StorageAccountModuleLink `
											  -ModuleName $AutomationAccountModuleName
	}
}
#endregion Publish